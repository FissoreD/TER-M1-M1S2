export class State{constructor(name,isAccepting,isInitial,alphabet){this.name=name;this.isAccepting=isAccepting;this.isInitial=isInitial;this.alphabet=alphabet;this.transitions=new Map;for(const symbol of alphabet){this.transitions.set(symbol,[])}}addTransition(symbol,state){this.transitions.get(symbol).push(state)}};export class Automaton{constructor(json){this.initialStates=json.initialStates;this.acceptingStates=json.acceptingStates;this.currentStates=this.initialStates;this.alphabet=Array.from(json.alphabet);this.states=json.states;this.states_rename=new Map;this.set_state_rename()}set_state_rename(){let counter_init=[0,this.initialStates.length,this.states.size-this.acceptingStates.length+1];for(const[_name,state]of this.states){if(this.initialStates.includes(state)){this.states_rename.set(state.name,"q"+counter_init[0]++)}else if(this.acceptingStates.includes(state)){this.states_rename.set(state.name,"q"+counter_init[2]++)}else{this.states_rename.set(state.name,"q"+counter_init[1]++)}}}next_step(next_char){let newCurrentState=[];this.currentStates.forEach(cs=>{let nextStates=cs.transitions.get(next_char);nextStates.forEach(nextState=>{if(!newCurrentState.includes(nextState)){newCurrentState.push(nextState)}})});this.currentStates=newCurrentState}accept_word(word){this.restart();Array.from(word).forEach(letter=>this.next_step(letter));let is_accepted=this.acceptingStates.some(e=>this.currentStates.includes(e));this.restart();return is_accepted}accept_word_nfa(word){let nextStates=new Set(this.initialStates);for(let index=0;index<word.length&&nextStates.size>0;index++){let nextStates2=new Set;const symbol=word[index];for(const state of nextStates){Array.from(this.findTransition(state,symbol)).forEach(e=>nextStates2.add(e))}nextStates=nextStates2}return Array.from(nextStates).some(e=>e.isAccepting)}findTransition(state,symbol){return this.states.get(state.name).transitions.get(symbol)}restart(){this.currentStates=this.initialStates}draw_next_step(next_char){this.color_node(false);this.next_step(next_char);this.color_node(true)}initiate_graph(){let automatonHTML=$("#automaton-mermaid")[0];automatonHTML.removeAttribute("data-processed");automatonHTML.innerHTML=this.matrix_to_mermaid();mermaid.init($(".mermaid"));this.acceptingStates.forEach(n=>{let circle=this.get_current_graph_node(n);circle.style.strokeWidth="1.1";circle.style.stroke="black";let smaller_circle=circle.cloneNode();smaller_circle.attributes["r"].value-=4;circle.parentNode.insertBefore(smaller_circle,circle.nextSibling)});this.color_node(true);$(".mermaid")[0].after($(".mermaidTooltip")[0]);$("svg")[0].style.height="auto"}get_current_graph_node(node){return Array.from($(".node")).find(e=>e.id.split("-")[1]==node.name).firstChild}matrix_to_mermaid(){let res="flowchart LR\n";res=res.concat("subgraph Automaton\ndirection LR\n");let triples={};for(const[name,state]of this.states){for(let j=0;j<this.alphabet.length;j++){for(const nextState of this.findTransition(state,this.alphabet[j])){let stateA_concat_stateB=name+"&"+nextState.name;if(triples[stateA_concat_stateB]){triples[stateA_concat_stateB].push(this.alphabet[j])}else{triples[stateA_concat_stateB]=[this.alphabet[j]]}}}}res=res.concat(Object.keys(triples).map(x=>this.create_triple(x,triples[x].join(","))).join("\n"));res+="\n";res+="subgraph InitialStates\n";res+=this.initialStates.map(e=>e.name).join("\n");res+="\nend";res+="\n";res+="end\n";res=res.concat(Array.from(this.states).map(([name,_])=>`click ${name} undnamefinedCallback "${name}";`).join("\n"));console.log(res);return res}color_node(toFill){this.currentStates.forEach(currentState=>{let current_circle=this.get_current_graph_node(currentState);let next_circle=current_circle.nextSibling;if(toFill){next_circle.style.textDecoration="underline";if(this.acceptingStates.includes(currentState))next_circle.style.fill="#009879";else current_circle.style.fill="#009879"}else{if(this.acceptingStates.includes(currentState))next_circle.removeAttribute("style");else current_circle.removeAttribute("style")}})}create_triple(states,transition){let split=states.split("&");let A=split[0],B=split[1];let A_rename=this.get_state_rename(A);let B_rename=this.get_state_rename(B);return`${A}((${A_rename})) -->| ${transition} | ${B}((${B_rename}))`}create_entering_arrow(){return`START[ ]--> ${this.initialStates}`}get_state_rename(name){return this.states_rename.get(name)}state_number(){return this.states.size}transition_number(){return Array.from(this.states).map(e=>Array.from(e[1].transitions)).flat().reduce((a,b)=>a+b[1].length,0)}}
//# sourceMappingURL=Automaton.js.map