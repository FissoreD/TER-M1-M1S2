export class State{constructor(name,isAccepting,isInitial,alphabet){this.name=name;this.isAccepting=isAccepting;this.isInitial=isInitial;this.alphabet=alphabet;this.outTransitions=new Map;this.inTransitions=new Map;this.successors=new Set;this.predecessor=new Set;for(const symbol of alphabet){this.outTransitions.set(symbol,[]);this.inTransitions.set(symbol,[])}}addTransition(symbol,state){if(this.outTransitions.get(symbol).includes(state))return;this.outTransitions.get(symbol).push(state);this.successors.add(state);state.predecessor.add(this);state.inTransitions.get(symbol).push(this)}getSuccessor(symbol){return this.outTransitions.get(symbol)}getPredecessor(symbol){return this.inTransitions.get(symbol)}static bottom(alphabet){return new State("bottom",false,false,alphabet)}};export class Automaton{constructor(stateList){this.complete(stateList);this.allStates=Array.from(stateList);this.initialStates=this.allStates.filter(s=>s.isInitial);this.acceptingStates=this.allStates.filter(s=>s.isAccepting);this.currentStates=this.initialStates;this.alphabet=this.initialStates[0].alphabet;this.states=new Map;stateList.forEach(e=>this.states.set(e.name,e));this.states_rename=new Map;this.set_state_rename()}complete(stateList){let alphabet=stateList.values().next().value.alphabet;let bottom=State.bottom(alphabet);for(const state of stateList){for(const symbol of alphabet){if(this.findTransition(state,symbol).length==0){stateList.add(bottom);state.addTransition(symbol,bottom)}}}}set_state_rename(){let counter_init=[0,this.initialStates.length,this.states.size-this.acceptingStates.length+1];for(const[_name,state]of this.states){if(this.initialStates.includes(state)){this.states_rename.set(state.name,"q"+counter_init[0]++)}else if(this.acceptingStates.includes(state)){this.states_rename.set(state.name,"q"+counter_init[2]++)}else{this.states_rename.set(state.name,"q"+counter_init[1]++)}}}next_step(next_char){let newCurrentState=[];this.currentStates.forEach(cs=>{let nextStates=cs.outTransitions.get(next_char);nextStates.forEach(nextState=>{if(!newCurrentState.includes(nextState)){newCurrentState.push(nextState)}})});this.currentStates=newCurrentState}accept_word(word){this.restart();Array.from(word).forEach(letter=>this.next_step(letter));let is_accepted=this.acceptingStates.some(e=>this.currentStates.includes(e));this.restart();return is_accepted}accept_word_nfa(word){if(word.length==0)return this.initialStates.some(e=>e.isAccepting);let nextStates=new Set(this.initialStates);for(let index=0;index<word.length&&nextStates.size>0;index++){let nextStates2=new Set;const symbol=word[index];for(const state of nextStates){for(const nextState of this.findTransition(state,symbol)){nextStates2.add(nextState);if(index==word.length-1&&nextState.isAccepting)return true}}nextStates=nextStates2}return false}findTransition(state,symbol){return state.outTransitions.get(symbol)}restart(){this.currentStates=this.initialStates}draw_next_step(next_char){this.color_node(false);this.next_step(next_char);this.color_node(true)}initiate_graph(){let automatonHTML=$("#automaton-mermaid")[0];automatonHTML.removeAttribute("data-processed");automatonHTML.innerHTML=this.matrix_to_mermaid();mermaid.init($(".mermaid"));this.acceptingStates.forEach(n=>{let circle=this.get_current_graph_node(n);circle.style.strokeWidth="1.1";circle.style.stroke="black";let smaller_circle=circle.cloneNode();smaller_circle.attributes["r"].value-=4;circle.parentNode.insertBefore(smaller_circle,circle.nextSibling)});this.color_node(true);$(".mermaid")[0].after($(".mermaidTooltip")[0]);$("svg")[0].style.height="auto"}get_current_graph_node(node){return Array.from($(".node")).find(e=>e.id.split("-")[1]==node.name).firstChild}matrix_to_mermaid(){let mermaidTxt="flowchart LR\n";mermaidTxt=mermaidTxt.concat("subgraph Automaton\ndirection LR\n");let triples={};for(const[name,state]of this.states){for(let j=0;j<this.alphabet.length;j++){for(const nextState of this.findTransition(state,this.alphabet[j])){let stateA_concat_stateB=name+"&"+nextState.name;if(triples[stateA_concat_stateB]){triples[stateA_concat_stateB].push(this.alphabet[j])}else{triples[stateA_concat_stateB]=[this.alphabet[j]]}}}}mermaidTxt=mermaidTxt.concat(Object.keys(triples).map(x=>this.create_triple(x,triples[x].join(","))).join("\n"));mermaidTxt+="\n";mermaidTxt+="\nsubgraph InitialStates\n";mermaidTxt+=this.initialStates.map(e=>e.name).join("\n");mermaidTxt+="\nend";mermaidTxt+="\n";mermaidTxt+="end\n";mermaidTxt=mermaidTxt.concat(this.acceptingStates.map(e=>`style ${e.name} fill:#FFFF00, stroke:#FF00FF;\n`).join(""));mermaidTxt+="\n";mermaidTxt=mermaidTxt.concat(Array.from(this.states).map(([name,_])=>`click ${name} undnamefinedCallback "${name}";`).join("\n"));return mermaidTxt}color_node(toFill){this.currentStates.forEach(currentState=>{let current_circle=this.get_current_graph_node(currentState);let next_circle=current_circle.nextSibling;if(toFill){next_circle.style.textDecoration="underline";if(this.acceptingStates.includes(currentState))next_circle.style.fill="#009879";else current_circle.style.fill="#009879"}else{if(this.acceptingStates.includes(currentState))next_circle.removeAttribute("style");else current_circle.removeAttribute("style")}})}create_triple(states,transition){let split=states.split("&");let A=split[0],B=split[1];let A_rename=this.get_state_rename(A);let B_rename=this.get_state_rename(B);return`${A}((${A_rename})) -->| ${transition} | ${B}((${B_rename}))`}create_entering_arrow(){return`START[ ]--> ${this.initialStates}`}get_state_rename(name){return this.states_rename.get(name)}state_number(){return this.states.size}transition_number(){return Array.from(this.states).map(e=>Array.from(e[1].outTransitions)).flat().reduce((a,b)=>a+b[1].length,0)}minimize(){let stateList=[this.initialStates[0]];let toExplore=[this.initialStates[0]];while(toExplore.length>0){let newState=toExplore.shift();for(const successor of newState.successors){if(!stateList.includes(successor)){toExplore.push(successor);stateList.push(successor)}}}let P=[new Set,new Set];stateList.forEach(s=>(s.isAccepting?P[0]:P[1]).add(s));P=P.filter(p=>p.size>0);let pLength=()=>P.reduce((a,p)=>a+p.size,0);let W=Array.from(P);while(W.length>0){let A=W.shift();for(const letter of this.alphabet){let X=new Set;A.forEach(e=>{let succ=e.inTransitions.get(letter);if(succ)succ.forEach(s=>X.add(s))});let Y=P.map(p=>{let S1=new Set,S2=new Set;for(const state of p){if(X.has(state))S1.add(state);else S2.add(state)}return{y:p,S1:S1,S2:S2}}).filter(({S1,S2})=>S1.size>0&&S2.size>0);for(const{y,S1,S2}of Y){P.splice(P.indexOf(y),1);P.push(S1);P.push(S2);if(pLength()!=stateList.length)throw`Wanted ${stateList.length} had ${pLength()}`;if(W.includes(y)){W.splice(W.indexOf(y),1);W.push(S1);W.push(S2)}else{if(S1.size<=S2.size){W.push(S1)}else{W.push(S2)}}}}}let oldStateToNewState=new Map;let newStates=new Set(Array.from(P).filter(partition=>partition.size>0).map((partition,pos)=>{let representant=Array.from(partition);let newState=new State(pos+"",representant.some(e=>e.isAccepting),representant.some(e=>e.isInitial),representant[0].alphabet);partition.forEach(state=>oldStateToNewState.set(state,newState));return newState}));for(const partition of P){for(const oldState of partition){for(const letter of this.alphabet){for(const successor of oldState.getSuccessor(letter)){if(!oldStateToNewState.get(oldState).outTransitions.get(letter)[0]||oldStateToNewState.get(oldState).outTransitions.get(letter)[0].name!=oldStateToNewState.get(successor).name)oldStateToNewState.get(oldState).addTransition(letter,oldStateToNewState.get(successor))}}}}return new Automaton(newStates)}}
//# sourceMappingURL=Automaton.js.map