import{Automaton,State}from"../automaton/Automaton.js";import{noam}from"../../public/noam.js";export function HisAutomaton2Mine(aut){let states=aut.states.map(e=>new State(e+"",aut.acceptingStates.map(e=>e+"").includes(e+""),(typeof aut.initialState=="number"?aut.initialState+""==e+"":aut.initialState?.map(e=>e+"").includes(e+""))||false,aut.alphabet));let statesMap=new Map;for(const state of states){statesMap.set(state.name,state)}for(const transition of aut.transitions){let from=transition.fromState;let symbol=transition.symbol;let to=transition.toStates;to.forEach(state=>statesMap.get(from+"")?.addTransition(symbol,statesMap.get(state+"")))}let res={alphabet:Array.from(aut.alphabet),initialStates:states.filter(s=>s.isInitial),acceptingStates:states.filter(s=>s.isAccepting),states:statesMap};return new Automaton(res)}export function MyAutomatonToHis(aut){let stateList=Array.from(aut.states).map(e=>e[1]);let state2int=state=>stateList.indexOf(state);let states=stateList.map(e=>state2int(e));let startState=states.length;let transitions=stateList.map(state=>Array.from(state.transitions).map(transition=>({fromState:state2int(state),symbol:transition[0],toStates:transition[1].map(e=>state2int(e))})).flat()).flat();if(aut.initialStates.length>1){transitions.push({fromState:startState,symbol:"$",toStates:aut.initialStates.map(e=>state2int(e))});states.push(startState)}else startState=state2int(aut.initialStates[0]);let res={acceptingStates:aut.acceptingStates.map(e=>state2int(e)),alphabet:Array.from(aut.alphabet),states:states,initialState:startState,transitions:transitions};return res}export function regexToAutomaton(regex){let res=noam.fsm.minimize(noam.re.string.toAutomaton(regex));return HisAutomaton2Mine(res)}export function minimizeAutomaton(automaton){let hisMinimized=noam.fsm.minimize(automaton);let statesToNumbers=noam.fsm.convertStatesToNumbers(hisMinimized);let minimized=HisAutomaton2Mine(statesToNumbers);return minimized}export function intersectionAutomata(a1,a2){return minimizeAutomaton(noam.fsm.intersection(MyAutomatonToHis(a1),MyAutomatonToHis(a2)))}export function unionAutomata(a1,a2){let A1=MyAutomatonToHis(a1);let A2=MyAutomatonToHis(a2);let U=noam.fsm.union(A1,A2);let res=minimizeAutomaton(U);return res}export function complementAutomata(a1){return minimizeAutomaton(noam.fsm.complement(MyAutomatonToHis(a1)))}export function differenceAutomata(a1,a2){let c=complementAutomata(a2);return intersectionAutomata(a1,c)}
//# sourceMappingURL=automaton_type.js.map