import{Automaton,State}from"../automaton/Automaton.js";import{noam}from"../../public/noam.js";export function HisAutomaton2Mine(aut){let states=aut.states.map(e=>new State(e+"",aut.acceptingStates.some(x=>x+""==e+""),(typeof aut.initialState=="number"?aut.initialState+""==e+"":aut.initialState?.some(x=>x+""==e+""))||false,aut.alphabet));let statesMap=new Map,statesSet=new Set;for(const state of states){statesMap.set(state.name,state);statesSet.add(state)}for(const transition of aut.transitions){let from=transition.fromState;let symbol=transition.symbol;let to=transition.toStates;to.forEach(state=>statesMap.get(from+"")?.addTransition(symbol,statesMap.get(state+"")))}return new Automaton(statesSet)}export function MyAutomatonToHis(aut){let stateList=Array.from(aut.states).map(e=>e[1]);let state2int=state=>stateList.indexOf(state);let states=stateList.map(e=>state2int(e));let startState=states.length;let transitions=stateList.map(state=>Array.from(state.outTransitions).map(transition=>({fromState:state2int(state),symbol:transition[0],toStates:transition[1].map(e=>state2int(e))})).flat()).flat();if(aut.initialStates.length>1){transitions.push({fromState:startState,symbol:"$",toStates:aut.initialStates.map(e=>state2int(e))});states.push(startState)}else startState=state2int(aut.initialStates[0]);let res={acceptingStates:aut.acceptingStates.map(e=>state2int(e)),alphabet:Array.from(aut.alphabet),states:states,initialState:startState,transitions:transitions};return res}export function regexToAutomaton(regex){let res=noam.re.string.toAutomaton(regex);return minimizeAutomaton(res)}export function minimizeAutomaton(automaton){automaton=noam.fsm.convertEnfaToNfa(automaton);automaton=noam.fsm.convertNfaToDfa(automaton);console.log("1");console.log("2");let statesToNumbers=noam.fsm.convertStatesToNumbers(automaton);console.log("3");let minimized=HisAutomaton2Mine(statesToNumbers).minimize();console.log("4");return minimized}export function intersectionAutomata(a1,a2){console.log("Intersection, ",a1.states.size,a2.states.size);return minimizeAutomaton(noam.fsm.intersection(MyAutomatonToHis(a1),MyAutomatonToHis(a2)))}export function unionAutomata(a1,a2){let A1=MyAutomatonToHis(a1);let A2=MyAutomatonToHis(a2);let U=noam.fsm.union(A1,A2);let res=minimizeAutomaton(U);return res}export function complementAutomata(a1){return minimizeAutomaton(noam.fsm.complement(MyAutomatonToHis(a1)))}export function differenceAutomata(a1,a2){let c=complementAutomata(a2);return intersectionAutomata(a1,c)}
//# sourceMappingURL=automaton_type.js.map