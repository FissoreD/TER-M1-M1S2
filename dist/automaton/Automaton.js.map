{"version":3,"sources":["../../src/automaton/Automaton.ts"],"names":["Automaton","states_rename","constructor","json","transitions","startState","acceptingStates","currentStates","alphabet","Array","from","states","set_state_rename","counter_init","length","i","includes","push","next_step","next_char","newCurrentState","forEach","cs","nextStates","find_transition","toStates","nextState","accept_word","word","restart","letter","is_accepted","some","e","state","symbol","filter","fromState","find","accept_word_nfa","path","recursive_explore","index","current_state","state_path","next_states","next_state","get_state_rename","start_state","draw_next_step","color_node","initiate_graph","automatonHTML","$","removeAttribute","innerHTML","matrix_to_mermaid","mermaid","init","n","circle","get_current_graph_node","style","strokeWidth","stroke","smaller_circle","cloneNode","attributes","value","parentNode","insertBefore","nextSibling","after","height","node","id","split","firstChild","res","concat","triples","j","stateA_concat_stateB","Object","keys","map","x","create_triple","join","s","console","log","toFill","currentState","current_circle","next_circle","textDecoration","fill","transition","A","B","A_rename","B_rename","create_entering_arrow","name","indexOf","state_number","transition_number","reduce","prev","current"],"mappings":"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","sourcesContent":["export interface Transition {\r\n  fromState: string,\r\n  toStates: string[],\r\n  symbol: string\r\n}\r\n\r\nexport interface AutomatonJson {\r\n  transitions: Transition[],\r\n  startState: string[],\r\n  acceptingStates: string[],\r\n  alphabet: string[] | string,\r\n  states: string[]\r\n};\r\n\r\nexport class Automaton implements AutomatonJson {\r\n  transitions: Transition[];\r\n  startState: string[];\r\n  acceptingStates: string[];\r\n  alphabet: string | string[];\r\n  states: string[];\r\n  states_rename: string[] = [];\r\n  currentStates: string[];\r\n\r\n  constructor(json: AutomatonJson) {\r\n    this.transitions = json.transitions;\r\n    this.startState = json.startState;\r\n    this.acceptingStates = json.acceptingStates;\r\n    this.currentStates = this.startState;\r\n    this.alphabet = Array.from(json.alphabet);\r\n    this.states = json.states;\r\n    this.set_state_rename()\r\n  }\r\n\r\n  set_state_rename() {\r\n    this.states_rename = [];\r\n    let counter_init = [0, this.startState.length, this.states.length - this.acceptingStates.length + 1];\r\n    for (let i = 0; i < this.states.length; i++) {\r\n      if (this.startState.includes(this.states[i])) {\r\n        this.states_rename.push(\"q\" + counter_init[0]++)\r\n      } else if (this.acceptingStates.includes(this.states[i])) {\r\n        this.states_rename.push(\"q\" + counter_init[2]++)\r\n      } else {\r\n        this.states_rename.push(\"q\" + counter_init[1]++)\r\n      }\r\n    }\r\n  }\r\n\r\n  next_step(next_char: string) {\r\n    let newCurrentState: string[] = []\r\n    this.currentStates.forEach(cs => {\r\n      let nextStates = this.find_transition(cs, next_char).toStates\r\n      nextStates.forEach(nextState => {\r\n        if (!newCurrentState.includes(nextState)) {\r\n          newCurrentState.push(nextState)\r\n        }\r\n      })\r\n    })\r\n    this.currentStates = newCurrentState;\r\n  }\r\n\r\n  accept_word(word: string): boolean {\r\n    this.restart()\r\n    Array.from(word).forEach(\r\n      letter => this.next_step(letter)\r\n    )\r\n    let is_accepted = this.acceptingStates.some(e => this.currentStates.includes(e));\r\n    this.restart()\r\n    return is_accepted;\r\n  }\r\n\r\n  find_transition(state: string, symbol: string) {\r\n    return this.transitions\r\n      .filter(e => e.fromState == state)\r\n      .find(e => e.symbol == symbol)!\r\n  }\r\n\r\n  accept_word_nfa(word: string): [boolean, string[]] {\r\n    let path: string[] = [];\r\n    let recursive_explore = (word: string, index: number, current_state: string, state_path: string): boolean => {\r\n      if (index < word.length) {\r\n        let next_states = this.find_transition(current_state, word[index]).toStates;\r\n        return next_states.some(next_state => recursive_explore(word, index + 1, next_state, state_path + \", \" + this.get_state_rename(next_state)))\r\n      } else {\r\n        if (this.acceptingStates.includes(current_state)) {\r\n          path = [state_path]\r\n          return true;\r\n        }\r\n        path.push(state_path)\r\n        return false;\r\n      }\r\n    }\r\n    let is_accepted: boolean = false;\r\n    for (const start_state of this.startState) {\r\n      is_accepted = recursive_explore(word, 0, start_state, this.get_state_rename(start_state));\r\n      if (is_accepted) break;\r\n    }\r\n\r\n    return [is_accepted, path];\r\n  }\r\n\r\n  restart() {\r\n    this.currentStates = this.startState;\r\n  }\r\n\r\n  /** GRAPHIC PART */\r\n\r\n  draw_next_step(next_char: string) {\r\n    this.color_node(false);\r\n    this.next_step(next_char);\r\n    this.color_node(true);\r\n  }\r\n\r\n  initiate_graph() {\r\n    let automatonHTML = $(\"#automaton-mermaid\")[0];\r\n    automatonHTML.removeAttribute('data-processed')\r\n    automatonHTML.innerHTML = this.matrix_to_mermaid();\r\n\r\n    // @ts-ignore\r\n    mermaid.init($(\".mermaid\"));\r\n\r\n    // Mark end nodes\r\n    this.acceptingStates.forEach(n => {\r\n      let circle = this.get_current_graph_node(n) as HTMLElement;\r\n      circle.style.strokeWidth = \"1.1\";\r\n      circle.style.stroke = \"black\"\r\n      let smaller_circle = circle.cloneNode() as HTMLElement;\r\n      // @ts-ignore\r\n      smaller_circle.attributes['r'].value -= 4\r\n      circle.parentNode!.insertBefore(smaller_circle, circle.nextSibling)\r\n    });\r\n\r\n    // Mark current node = initial state\r\n    this.color_node(true);\r\n    $(\".mermaid\")[0].after($(\".mermaidTooltip\")[0])\r\n    $('svg')[0].style.height = 'auto'\r\n  }\r\n\r\n  get_current_graph_node(node: string) {\r\n    return Array.from($(\".node\")).find(e => e.id.split(\"-\")[1] == node)!.firstChild!;\r\n  }\r\n\r\n  matrix_to_mermaid(): string {\r\n    let res = \"flowchart LR\\n\";\r\n    res = res.concat(\"subgraph Automaton\\ndirection LR\\n\")\r\n    // res = res.concat(\"\\n\" + this.create_entering_arrow() + \"\\n\");\r\n    let triples: { [id: string]: string[] } = {}\r\n    for (let i = 0; i < this.states.length; i++) {\r\n      for (let j = 0; j < this.alphabet.length; j++) {\r\n        for (const state of this.find_transition(this.states[i], this.alphabet[j]).toStates) {\r\n          let stateA_concat_stateB = this.states[i] + '&' + state;\r\n          if (triples[stateA_concat_stateB]) {\r\n            triples[stateA_concat_stateB].push(this.alphabet[j])\r\n          } else {\r\n            triples[stateA_concat_stateB] = [this.alphabet[j]]\r\n          }\r\n        }\r\n      }\r\n    }\r\n    res = res.concat(Object.keys(triples).map(x => this.create_triple(x, triples[x].join(\",\"))).join(\"\\n\"));\r\n    // res = res.concat(\"\\nstyle START fill:#FFFFFF, stroke:#FFFFFF;\")\r\n    res += \"\\n\"\r\n    // res = res.concat(this.startState.map(e => `style ${e} fill:#FFFF00, stroke:#FF00FF;\\n`).join(\"\"));\r\n    res += \"subgraph InitialStates\\n\";\r\n    res += this.startState.map(e => e).join(\"\\n\")\r\n    res += \"\\nend\\n\"\r\n\r\n    this.acceptingStates.forEach(s => res += `style ${s} fill:#00758f\\n`)\r\n\r\n    res += \"\\nend\\n\"\r\n    // Callback for tooltip on mouse over\r\n    res = res.concat(this.states.map(e => `click ${e} undefinedCallback \"${e}\";`).join(\"\\n\"))\r\n    console.log(res);\r\n    return res;\r\n  }\r\n\r\n\r\n  color_node(toFill: boolean) {\r\n    this.currentStates.forEach(currentState => {\r\n      let current_circle = this.get_current_graph_node(currentState) as HTMLElement;\r\n      let next_circle = current_circle.nextSibling as HTMLElement;\r\n      if (toFill) {\r\n        next_circle.style.textDecoration = \"underline\";\r\n        if (this.acceptingStates.includes(currentState))\r\n          next_circle.style.fill = '#009879';\r\n        else current_circle.style.fill = '#009879';\r\n      } else {\r\n        if (this.acceptingStates.includes(currentState))\r\n          next_circle.removeAttribute('style');\r\n        else current_circle.removeAttribute('style');\r\n      }\r\n    })\r\n    // let currentNode = this.get_current_graph_node(this.currentState).parentElement as HTMLElement;\r\n    // let spanWithText = currentNode.getElementsByClassName(\"nodeLabel\")![0] as HTMLElement;\r\n    // if (toFill) {\r\n    //   spanWithText.style.textDecoration = \"underline\";\r\n    // } else {\r\n    //   spanWithText.removeAttribute('style');\r\n    // }\r\n  }\r\n\r\n  create_triple(states: string, transition: string): string {\r\n    let split = states.split(\"&\");\r\n    let A = split[0], B = split[1];\r\n    let A_rename = this.get_state_rename(A);\r\n    let B_rename = this.get_state_rename(B);\r\n    return `${A}((${A_rename})) -->| ${transition} | ${B}((${B_rename}))`;\r\n  }\r\n\r\n  create_entering_arrow(): string {\r\n    return `START[ ]--> ${this.startState}`\r\n  }\r\n\r\n  get_state_rename(name: string) {\r\n    // return name;\r\n    return this.states_rename[this.states.indexOf(name)]\r\n  }\r\n\r\n  state_number() {\r\n    return this.states.length;\r\n  }\r\n\r\n  transition_number() {\r\n    return this.transitions.map(e => e.toStates.length).reduce((prev, current) => prev + current);\r\n  }\r\n\r\n  // minimize() {\r\n  //   let couples: string[][] = []\r\n  //   let separable = new Set();\r\n\r\n\r\n  //   let reachableStates = () => {\r\n  //     let reachable: string[] = [];\r\n  //     let toExplore: string[] | undefined = Array.from(this.startState);\r\n  //     while (toExplore.length > 0) {\r\n  //       console.log(\"HERE\");\r\n  //       let current = toExplore.shift()!\r\n  //       reachable.push(current)\r\n  //       let neighbors = this.transitions.filter(t => t.fromState == current).map(t => t.toStates).flat()\r\n  //       for (const neighbor of neighbors) {\r\n  //         if (!reachable.includes(neighbor) && !toExplore.includes(neighbor)) {\r\n  //           toExplore.push(neighbor)\r\n  //         }\r\n  //       }\r\n  //     }\r\n  //     return reachable\r\n  //   }\r\n\r\n  //   let reachables = reachableStates();\r\n\r\n  //   for (let i1 = 0; i1 < reachables.length; i1++) {\r\n  //     for (let i2 = i1 + 1; i2 < reachables.length; i2++) {\r\n  //       if (this.acceptingStates.includes(reachables[i1]) != this.acceptingStates.includes(reachables[i2])) separable.add(`${reachables[i1]}-${reachables[i2]}`)\r\n  //       else couples.push([reachables[i1], reachables[i2]]);\r\n  //     }\r\n  //   }\r\n\r\n  //   while (true) {\r\n  //     let oldLength = couples.length;\r\n  //     couples = couples.filter(e => {\r\n  //       let fst = e[0], snd = e[1];\r\n  //       let tr0 = this.transitions.filter(t => t.fromState == fst);\r\n  //       let tr1 = this.transitions.filter(t => t.fromState == snd);\r\n  //       for (const letter of this.alphabet) {\r\n  //         let t1 = tr0.find(e => e.symbol == letter)?.toStates\r\n  //         let t2 = tr1.find(e => e.symbol == letter)?.toStates\r\n  //         if (t1 && t2) {\r\n  //           for (const x of t1) {\r\n  //             for (const y of t2) {\r\n  //               if (separable.has(`${x}-${y}`) || separable.has(`${y}-${x}`)) {\r\n  //                 separable.add(`${fst}-${snd}`)\r\n  //                 return false;\r\n  //               }\r\n  //             }\r\n  //           }\r\n  //         }\r\n  //       }\r\n  //       return true;\r\n  //     })\r\n  //     if (couples.length == oldLength) break\r\n  //   }\r\n\r\n  //   let statesMerged = Array.from(reachables)\r\n  //   let transitions: { [key: string]: Transition[] } = {};\r\n  //   for (const iterator of couples) {\r\n  //     let a = iterator[0], b = iterator[1];\r\n  //     statesMerged = statesMerged.filter(e => e != (this.startState.includes(b) ? a : b))\r\n  //   }\r\n\r\n  //   let mergeListWithoutRepetition = (L1: string[], L2: string[]) => {\r\n  //     let s = new Set()\r\n  //     L1.forEach(e => s.add(e))\r\n  //     L2.forEach(e => s.add(e))\r\n  //   }\r\n\r\n  //   let createValidTransition = (transition: Transition): Transition => ({\r\n  //     fromState: transition.fromState,\r\n  //     toStates: transition.toStates.filter(e => statesMerged.includes(e)),\r\n  //     symbol: transition.symbol\r\n  //   })\r\n\r\n  //   let extendWithoutRepetition = (t1: Transition[], t2: Transition) => {\r\n  //     let t;\r\n  //     if (t = t1.find(x => x.symbol == t2.symbol))\r\n  //       for (const state of t2.toStates) {\r\n  //         if (!t.toStates.includes(state) && statesMerged.includes(state)) t.toStates.push(state)\r\n  //       }\r\n  //     else t1.push(createValidTransition(t2))\r\n  //   }\r\n\r\n  //   for (const couple of couples) {\r\n  //     let a = couple[0], b = couple[1];\r\n  //     let tA = this.transitions.filter(t => t.fromState == a)\r\n  //     let tB = this.transitions.filter(t => t.fromState == b)\r\n  //     if (statesMerged.includes(a)) {\r\n  //       if (!transitions[a])\r\n  //         transitions[a] = tA.map(e => createValidTransition(e));\r\n  //       else tA.forEach(e => {\r\n  //         extendWithoutRepetition(transitions[a], e)\r\n  //       });\r\n  //       tB.forEach(e => extendWithoutRepetition(transitions[a], e))\r\n  //     } else if (statesMerged.includes(b)) {\r\n  //       if (!transitions[b])\r\n  //         transitions[b] = tB.map(e => createValidTransition(e));\r\n  //       else tB.forEach(e => extendWithoutRepetition(transitions[b], e));\r\n  //       tA.forEach(e => extendWithoutRepetition(transitions[b], e))\r\n  //     }\r\n  //   }\r\n\r\n  //   let startStates = statesMerged.filter(e => this.startState.includes(e))\r\n  //   let acceptingStates = statesMerged.filter(e => this.acceptingStates.includes(e))\r\n  //   let o = Object.entries(transitions).map(e => e[1][0]).filter(t => t.toStates.length != 0)\r\n\r\n  //   let newAutomaton: AutomatonJson = {\r\n  //     transitions: [],\r\n  //     startState: [],\r\n  //     acceptingStates: [],\r\n  //     alphabet: this.alphabet,\r\n  //     states: reachables\r\n  //   }\r\n\r\n  //   console.log(Array.from(separable), couples);\r\n\r\n  //   return this;\r\n\r\n  //   // for (const couple of couples) {\r\n  //   //   this.transitions.filter(e => e.fromState == couple[1]).forEach(\r\n  //   //     s => {\r\n  //   //       let tr;\r\n  //   //       if (tr = this.transitions.find(t => t.fromState == couple[0] && t.symbol == s.symbol)) {\r\n  //   //         for (const next of s.toStates) {\r\n  //   //           if (!tr.toStates.includes(next)) tr.toStates.push(next)\r\n  //   //         }\r\n  //   //       } else {\r\n  //   //         newAutomaton.transitions.push({ fromState: couple[0], symbol: s.symbol, toStates: s.toStates })\r\n  //   //       }\r\n  //   //     }\r\n  //   //   )\r\n  //   //   if (this.startState.includes(couple[1])) {\r\n  //   //     this.startState = this.startState.filter(e => e != couple[1])\r\n  //   //     if (!this.startState.includes(couple[0])) this.startState.push(couple[0])\r\n  //   //   }\r\n  //   //   this.acceptingStates = this.acceptingStates.filter(e => e != couple[1])\r\n  //   //   this.states = this.states.filter(e => e != couple[1])\r\n  //   //   this.transitions = this.transitions.filter(e => e.fromState != couple[1])\r\n  //   //   this.transitions.forEach(e => e.toStates = e.toStates.filter(x => x != couple[1]))\r\n  //   //   this.transitions = this.transitions.filter(t => t.toStates.length != 0)\r\n  //   // }\r\n\r\n  //   // this.set_state_rename()\r\n  //   // console.log(Array.from(separable), couples);\r\n  //   // return this;\r\n  // }\r\n}"],"file":"Automaton.js"}