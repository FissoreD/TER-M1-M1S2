import{Automaton,State}from"../automaton/Automaton.js";import{LearnerBase}from"./LearnerBase.js";export class NL_star extends LearnerBase{constructor(teacher){super(teacher);this.prime_lines=Array.from(this.alphabet).concat("")}is_prime(row_key){if(this.prime_lines==undefined)this.prime_lines=[];let row_value=this.observation_table[row_key];if(row_value.length<2||parseInt(row_value)==0)return true;let res="0".repeat(row_value.length);Object.values(this.observation_table).forEach(value=>{if(value!=row_value&&this.is_covered(value,row_value)){res=this.row_union(res,value)}});return res!=row_value}row_union(row1,row2){return Array.from(row1).map((e,pos)=>[e,row2.charAt(pos)].includes("1")?"1":"0").join("")}is_covered(row1,row2){return Array.from(row1).every((e,pos)=>e<=row2.charAt(pos))}check_prime_lines(){this.prime_lines=[...this.S,...this.SA].filter(l=>this.is_prime(l))}add_elt_in_S(new_elt,after_equiv=false){super.add_elt_in_S(new_elt,after_equiv);this.check_prime_lines();return}add_elt_in_E(new_elt,after_equiv=false){super.add_elt_in_E(new_elt,after_equiv);this.check_prime_lines();return}is_close(){let res=this.SA.find(t=>!this.S.some(s=>this.same_row(s,t))&&this.prime_lines.includes(t));this.closedness_counter+=res==undefined?0:1;return res}is_consistent(){let testCovering=(s1,s2)=>{let value_s1=this.observation_table[s1];let value_s2=this.observation_table[s2];if(this.is_covered(value_s1,value_s2)){for(const a of this.alphabet){let value_s1_p=this.observation_table[s1+a];let value_s2_p=this.observation_table[s2+a];if(!this.is_covered(value_s1_p,value_s2_p)){for(let i=0;i<this.E.length;i++){if(this.observation_table[s1+a][i]>this.observation_table[s2+a][i]&&!this.E.includes(a+this.E[i])){this.consistence_counter++;return[s1,s2,a+this.E[i]]}}}}return}};for(let s1_ind=0;s1_ind<this.S.length;s1_ind++){for(let s2_ind=s1_ind+1;s2_ind<this.S.length;s2_ind++){let s1=this.S[s1_ind];let s2=this.S[s2_ind];let test1=testCovering(s1,s2);if(test1)return test1;let test2=testCovering(s2,s1);if(test2)return test2}}return}make_automaton(){let wordForState=[],statesMap=new Map,acceptingStates=[],initialStates=[],stateSet=new Set;this.prime_lines.forEach(s=>{if(this.S.includes(s)){let name=this.observation_table[s];if(!statesMap.get(name)){let state=new State(name,name[0]=="1",this.is_covered(name,this.observation_table[""]),this.alphabet);wordForState.push(s);if(state.isAccepting)acceptingStates.push(state);if(state.isInitial)initialStates.push(state);statesMap.set(name,state);stateSet.add(state)}}});for(const word of wordForState){let name=this.observation_table[word];for(const symbol of this.alphabet){let rowNext=this.observation_table[word+symbol];for(const[name1,state]of statesMap){if(this.is_covered(name1,rowNext))statesMap.get(name).outTransitions.get(symbol).push(state)}}}this.automaton=new Automaton(stateSet);return this.automaton}table_to_update_after_equiv(answer){this.add_elt_in_E(answer,true)}}
//# sourceMappingURL=NL_star.js.map