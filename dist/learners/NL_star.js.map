{"version":3,"sources":["../../src/learners/NL_star.ts"],"names":["Automaton","State","LearnerBase","NL_star","constructor","teacher","prime_lines","Array","from","alphabet","concat","is_prime","row_key","undefined","row_value","observation_table","length","parseInt","res","repeat","Object","values","forEach","value","is_covered","row_union","row1","row2","map","e","pos","charAt","includes","join","every","check_prime_lines","S","SA","filter","l","add_elt_in_S","new_elt","add_elt_in_E","is_close","find","t","some","s","same_row","is_consistent","testCovering","s1","s2","value_s1","value_s2","a","value_s1_p","value_s2_p","i","E","s1_ind","s2_ind","test1","test2","make_automaton","wordForState","statesMap","Map","acceptingStates","initialStates","stateSet","Set","name","get","state","push","isAccepting","isInitial","set","add","word","symbol","rowNext","name1","outTransitions","automaton","table_to_update_after_equiv","answer"],"mappings":"AAAA,OAASA,SAAT,CAAoBC,KAApB,KAAiC,2BAAjC,CAGA,OAASC,WAAT,KAA+C,kBAA/C,CAEA,MAAO,MAAMC,CAAAA,OAAN,QAAsBD,CAAAA,WAAY,CAGvCE,WAAW,CAACC,OAAD,CAAmB,CAC5B,MAAMA,OAAN,EACA,KAAKC,WAAL,CAAmBC,KAAK,CAACC,IAAN,CAAW,KAAKC,QAAhB,EAA0BC,MAA1B,CAAiC,EAAjC,CACpB,CAEDC,QAAQ,CAACC,OAAD,CAA2B,CACjC,GAAI,KAAKN,WAAL,EAAoBO,SAAxB,CAAmC,KAAKP,WAAL,CAAmB,EAAnB,CACnC,GAAIQ,CAAAA,SAAS,CAAG,KAAKC,iBAAL,CAAuBH,OAAvB,CAAhB,CACA,GAAIE,SAAS,CAACE,MAAV,CAAmB,CAAnB,EAAwBC,QAAQ,CAACH,SAAD,CAAR,EAAuB,CAAnD,CAAsD,MAAO,KAAP,CAEtD,GAAII,CAAAA,GAAG,CAAG,IAAIC,MAAJ,CAAWL,SAAS,CAACE,MAArB,CAAV,CAEAI,MAAM,CAACC,MAAP,CAAc,KAAKN,iBAAnB,EAAsCO,OAAtC,CAA8CC,KAAK,EAAI,CACrD,GAAIA,KAAK,EAAIT,SAAT,EAAsB,KAAKU,UAAL,CAAgBD,KAAhB,CAAuBT,SAAvB,CAA1B,CAA6D,CAC3DI,GAAG,CAAG,KAAKO,SAAL,CAAeP,GAAf,CAAoBK,KAApB,CACP,CACF,CAJD,EAKA,MAAOL,CAAAA,GAAG,EAAIJ,SACf,CAQDW,SAAS,CAACC,IAAD,CAAeC,IAAf,CAAqC,CAC5C,MAAOpB,CAAAA,KAAK,CAACC,IAAN,CAAWkB,IAAX,EAAiBE,GAAjB,CAAqB,CAACC,CAAD,CAAIC,GAAJ,GAAY,CAACD,CAAD,CAAIF,IAAI,CAACI,MAAL,CAAYD,GAAZ,CAAJ,EAAsBE,QAAtB,CAA+B,GAA/B,EAAsC,GAAtC,CAA4C,GAA7E,EAAkFC,IAAlF,CAAuF,EAAvF,CACR,CASDT,UAAU,CAACE,IAAD,CAAeC,IAAf,CAAsC,CAC9C,MAAOpB,CAAAA,KAAK,CAACC,IAAN,CAAWkB,IAAX,EAAiBQ,KAAjB,CAAuB,CAACL,CAAD,CAAIC,GAAJ,GAAYD,CAAC,EAAIF,IAAI,CAACI,MAAL,CAAYD,GAAZ,CAAxC,CACR,CAEDK,iBAAiB,EAAG,CAClB,KAAK7B,WAAL,CAAmB,CAAC,GAAG,KAAK8B,CAAT,CAAY,GAAG,KAAKC,EAApB,EAAwBC,MAAxB,CAA+BC,CAAC,EAAI,KAAK5B,QAAL,CAAc4B,CAAd,CAApC,CACpB,CAEDC,YAAY,CAACC,OAAD,CAAkB,CAC5B,MAAMD,YAAN,CAAmBC,OAAnB,EACA,KAAKN,iBAAL,GACA,MACD,CAEDO,YAAY,CAACD,OAAD,CAAwB,CAClC,MAAMC,YAAN,CAAmBD,OAAnB,EACA,KAAKN,iBAAL,GACA,MACD,CAQDQ,QAAQ,EAAuB,CAC7B,MAAO,MAAKN,EAAL,CAAQO,IAAR,CAAaC,CAAC,EAAI,CAAC,KAAKT,CAAL,CAAOU,IAAP,CAAYC,CAAC,EAAI,KAAKC,QAAL,CAAcD,CAAd,CAAiBF,CAAjB,CAAjB,CAAD,EAA0C,KAAKvC,WAAL,CAAiB0B,QAAjB,CAA0Ba,CAA1B,CAA5D,CACR,CAODI,aAAa,EAAyB,CACpC,GAAIC,CAAAA,YAAY,CAAG,CAACC,EAAD,CAAaC,EAAb,GAAkD,CACnE,GAAIC,CAAAA,QAAQ,CAAG,KAAKtC,iBAAL,CAAuBoC,EAAvB,CAAf,CACA,GAAIG,CAAAA,QAAQ,CAAG,KAAKvC,iBAAL,CAAuBqC,EAAvB,CAAf,CACA,GAAI,KAAK5B,UAAL,CAAgB6B,QAAhB,CAA0BC,QAA1B,CAAJ,CAAyC,CACvC,IAAK,KAAMC,CAAAA,CAAX,GAAgB,MAAK9C,QAArB,CAA+B,CAC7B,GAAI+C,CAAAA,UAAU,CAAG,KAAKzC,iBAAL,CAAuBoC,EAAE,CAAGI,CAA5B,CAAjB,CACA,GAAIE,CAAAA,UAAU,CAAG,KAAK1C,iBAAL,CAAuBqC,EAAE,CAAGG,CAA5B,CAAjB,CACA,GAAI,CAAC,KAAK/B,UAAL,CAAgBgC,UAAhB,CAA4BC,UAA5B,CAAL,CAA8C,CAC5C,IAAK,GAAIC,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAG,KAAKC,CAAL,CAAO3C,MAA3B,CAAmC0C,CAAC,EAApC,CAAwC,CACtC,GAAI,KAAK3C,iBAAL,CAAuBoC,EAAE,CAAGI,CAA5B,EAA+BG,CAA/B,EACF,KAAK3C,iBAAL,CAAuBqC,EAAE,CAAGG,CAA5B,EAA+BG,CAA/B,CADE,EACmC,CAAC,KAAKC,CAAL,CAAO3B,QAAP,CAAgBuB,CAAC,CAAG,KAAKI,CAAL,CAAOD,CAAP,CAApB,CADxC,CACwE,CACtE,MAAO,CAACP,EAAD,CAAKC,EAAL,CAASG,CAAC,CAAG,KAAKI,CAAL,CAAOD,CAAP,CAAb,CACR,CACF,CACF,CACF,CACD,MACD,CAED,IAAK,GAAIE,CAAAA,MAAM,CAAG,CAAlB,CAAqBA,MAAM,CAAG,KAAKxB,CAAL,CAAOpB,MAArC,CAA6C4C,MAAM,EAAnD,CAAuD,CACrD,IAAK,GAAIC,CAAAA,MAAM,CAAGD,MAAM,CAAG,CAA3B,CAA8BC,MAAM,CAAG,KAAKzB,CAAL,CAAOpB,MAA9C,CAAsD6C,MAAM,EAA5D,CAAgE,CAC9D,GAAIV,CAAAA,EAAE,CAAG,KAAKf,CAAL,CAAOwB,MAAP,CAAT,CACA,GAAIR,CAAAA,EAAE,CAAG,KAAKhB,CAAL,CAAOyB,MAAP,CAAT,CACA,GAAIC,CAAAA,KAAK,CAAGZ,YAAY,CAACC,EAAD,CAAKC,EAAL,CAAxB,CACA,GAAIU,KAAJ,CAAW,MAAOA,CAAAA,KAAP,CACX,GAAIC,CAAAA,KAAK,CAAGb,YAAY,CAACE,EAAD,CAAKD,EAAL,CAAxB,CACA,GAAIY,KAAJ,CAAW,MAAOD,CAAAA,KACnB,CACF,CACF,CA7BD,CA8BA,MACD,CAEDE,cAAc,EAAG,CACf,GAAIC,CAAAA,YAAsB,CAAG,EAA7B,CAAiCC,SAA6B,CAAG,GAAIC,CAAAA,GAArE,CACEC,eAAwB,CAAG,EAD7B,CACiCC,aAAsB,CAAG,EAD1D,CAC8DC,QAAoB,CAAG,GAAIC,CAAAA,GADzF,CAEA,KAAKjE,WAAL,CAAiBgB,OAAjB,CAAyByB,CAAC,EAAI,CAC5B,GAAI,KAAKX,CAAL,CAAOJ,QAAP,CAAgBe,CAAhB,CAAJ,CAAwB,CACtB,GAAIyB,CAAAA,IAAI,CAAG,KAAKzD,iBAAL,CAAuBgC,CAAvB,CAAX,CACA,GAAI,CAACmB,SAAS,CAACO,GAAV,CAAcD,IAAd,CAAL,CAA0B,CACxB,GAAIE,CAAAA,KAAK,CAAG,GAAIzE,CAAAA,KAAJ,CAAUuE,IAAV,CAAgBA,IAAI,CAAC,CAAD,CAAJ,EAAW,GAA3B,CAAgC,KAAKhD,UAAL,CAAgBgD,IAAhB,CAAsB,KAAKzD,iBAAL,CAAuB,EAAvB,CAAtB,CAAhC,CAAmF,KAAKN,QAAxF,CAAZ,CACAwD,YAAY,CAACU,IAAb,CAAkB5B,CAAlB,EACA,GAAI2B,KAAK,CAACE,WAAV,CAAuBR,eAAe,CAACO,IAAhB,CAAqBD,KAArB,EACvB,GAAIA,KAAK,CAACG,SAAV,CAAqBR,aAAa,CAACM,IAAd,CAAmBD,KAAnB,EACrBR,SAAS,CAACY,GAAV,CAAcN,IAAd,CAAoBE,KAApB,EACAJ,QAAQ,CAACS,GAAT,CAAaL,KAAb,CACD,CACF,CACF,CAZD,EAaA,IAAK,KAAMM,CAAAA,IAAX,GAAmBf,CAAAA,YAAnB,CAAiC,CAC/B,GAAIO,CAAAA,IAAI,CAAG,KAAKzD,iBAAL,CAAuBiE,IAAvB,CAAX,CACA,IAAK,KAAMC,CAAAA,MAAX,GAAqB,MAAKxE,QAA1B,CAAoC,CAClC,GAAIyE,CAAAA,OAAO,CAAG,KAAKnE,iBAAL,CAAuBiE,IAAI,CAAGC,MAA9B,CAAd,CACA,IAAK,KAAM,CAACE,KAAD,CAAQT,KAAR,CAAX,EAA6BR,CAAAA,SAA7B,CAAwC,CACtC,GAAI,KAAK1C,UAAL,CAAgB2D,KAAhB,CAAuBD,OAAvB,CAAJ,CACEhB,SAAS,CAACO,GAAV,CAAcD,IAAd,EAAqBY,cAArB,CAAoCX,GAApC,CAAwCQ,MAAxC,EAAiDN,IAAjD,CAAsDD,KAAtD,CACH,CACF,CACF,CACD,KAAKW,SAAL,CAAiB,GAAIrF,CAAAA,SAAJ,CAAcsE,QAAd,CAAjB,CACA,MAAO,MAAKe,SACb,CAEDC,2BAA2B,CAACC,MAAD,CAAuB,CAChD,KAAK7C,YAAL,CAAkB6C,MAAlB,CACD,CA7IsC","sourcesContent":["import { Automaton, State } from \"../automaton/Automaton.js\";\r\nimport { Teacher } from \"../teacher/Teacher.js\";\r\nimport { generate_suffix_list } from \"../tools/Utilities.js\";\r\nimport { LearnerBase, Map_string_string } from \"./LearnerBase.js\";\r\n\r\nexport class NL_star extends LearnerBase {\r\n  prime_lines: string[];\r\n\r\n  constructor(teacher: Teacher) {\r\n    super(teacher);\r\n    this.prime_lines = Array.from(this.alphabet).concat(\"\");\r\n  }\r\n\r\n  is_prime(row_key: string): boolean {\r\n    if (this.prime_lines == undefined) this.prime_lines = []\r\n    let row_value = this.observation_table[row_key];\r\n    if (row_value.length < 2 || parseInt(row_value) == 0) return true;\r\n\r\n    let res = \"0\".repeat(row_value.length)\r\n\r\n    Object.values(this.observation_table).forEach(value => {\r\n      if (value != row_value && this.is_covered(value, row_value)) {\r\n        res = this.row_union(res, value);\r\n      }\r\n    });\r\n    return res != row_value;\r\n  }\r\n\r\n  /**\r\n   * Given two rows, {@link row1} and {@link row2} \r\n   * it return the union of them, that is the logic \r\n   * or of them, for exemple : row_union(0101, 0110) \r\n   * returns 0111\r\n   */\r\n  row_union(row1: string, row2: string): string {\r\n    return Array.from(row1).map((e, pos) => [e, row2.charAt(pos)].includes(\"1\") ? \"1\" : \"0\").join(\"\");\r\n  }\r\n\r\n  /**\r\n   * returns if {@link row1} is covered by {@link row2}\r\n   * row1 is covered if every bit of is smaller then the \r\n   * corresponding bit of row2. For exemple :\r\n   * 01100 is covered by 01110\r\n   * 01101 is not covered by 01110 (due to last bit of r1)\r\n   */\r\n  is_covered(row1: string, row2: string): boolean {\r\n    return Array.from(row1).every((e, pos) => e <= row2.charAt(pos));\r\n  }\r\n\r\n  check_prime_lines() {\r\n    this.prime_lines = [...this.S, ...this.SA].filter(l => this.is_prime(l));\r\n  }\r\n\r\n  add_elt_in_S(new_elt: string) {\r\n    super.add_elt_in_S(new_elt);\r\n    this.check_prime_lines()\r\n    return;\r\n  }\r\n\r\n  add_elt_in_E(new_elt: string): void {\r\n    super.add_elt_in_E(new_elt);\r\n    this.check_prime_lines()\r\n    return;\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * @returns the first `s` in {@link SA} st `s` is a prime line and \r\n   * `s` is not in {@link S}\r\n   */\r\n  is_close(): string | undefined {\r\n    return this.SA.find(t => !this.S.some(s => this.same_row(s, t)) && this.prime_lines.includes(t));\r\n  }\r\n\r\n  /**\r\n   * @returns a list of 3 elements, \r\n   * the first two are s1, s2 in {@link S} st row(s1) is covered by row(s2)\r\n   * and there is an \"a\" in alphabet st row(s1 + a) is not covered row(s2 + a)\r\n   */\r\n  is_consistent(): string[] | undefined {\r\n    let testCovering = (s1: string, s2: string): string[] | undefined => {\r\n      let value_s1 = this.observation_table[s1];\r\n      let value_s2 = this.observation_table[s2];\r\n      if (this.is_covered(value_s1, value_s2)) {\r\n        for (const a of this.alphabet) {\r\n          let value_s1_p = this.observation_table[s1 + a]\r\n          let value_s2_p = this.observation_table[s2 + a]\r\n          if (!this.is_covered(value_s1_p, value_s2_p)) {\r\n            for (let i = 0; i < this.E.length; i++) {\r\n              if (this.observation_table[s1 + a][i] <\r\n                this.observation_table[s2 + a][i] && !this.E.includes(a + this.E[i])) {\r\n                return [s1, s2, a + this.E[i]]\r\n              }\r\n            }\r\n          }\r\n        }\r\n        return;\r\n      }\r\n\r\n      for (let s1_ind = 0; s1_ind < this.S.length; s1_ind++) {\r\n        for (let s2_ind = s1_ind + 1; s2_ind < this.S.length; s2_ind++) {\r\n          let s1 = this.S[s1_ind];\r\n          let s2 = this.S[s2_ind];\r\n          let test1 = testCovering(s1, s2);\r\n          if (test1) return test1;\r\n          let test2 = testCovering(s2, s1);\r\n          if (test2) return test1;\r\n        }\r\n      }\r\n    }\r\n    return;\r\n  }\r\n\r\n  make_automaton() {\r\n    let wordForState: string[] = [], statesMap: Map<string, State> = new Map(),\r\n      acceptingStates: State[] = [], initialStates: State[] = [], stateSet: Set<State> = new Set();\r\n    this.prime_lines.forEach(s => {\r\n      if (this.S.includes(s)) {\r\n        let name = this.observation_table[s];\r\n        if (!statesMap.get(name)) {\r\n          let state = new State(name, name[0] == \"1\", this.is_covered(name, this.observation_table[\"\"]), this.alphabet);\r\n          wordForState.push(s);\r\n          if (state.isAccepting) acceptingStates.push(state)\r\n          if (state.isInitial) initialStates.push(state)\r\n          statesMap.set(name, state);\r\n          stateSet.add(state)\r\n        }\r\n      }\r\n    })\r\n    for (const word of wordForState) {\r\n      let name = this.observation_table[word]\r\n      for (const symbol of this.alphabet) {\r\n        let rowNext = this.observation_table[word + symbol]\r\n        for (const [name1, state] of statesMap) {\r\n          if (this.is_covered(name1, rowNext))\r\n            statesMap.get(name)!.outTransitions.get(symbol)!.push(state)\r\n        }\r\n      }\r\n    }\r\n    this.automaton = new Automaton(stateSet)\r\n    return this.automaton;\r\n  }\r\n\r\n  table_to_update_after_equiv(answer: string): void {\r\n    this.add_elt_in_E(answer);\r\n  }\r\n}"],"file":"NL_star.js"}