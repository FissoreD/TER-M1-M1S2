{"version":3,"sources":["../../src/lerners/NL_star.ts"],"names":["Automaton","State","generate_suffix_list","LernerBase","NL_star","constructor","teacher","prime_lines","Array","from","alphabet","concat","is_prime","row_key","undefined","row_value","observation_table","length","parseInt","res","repeat","Object","values","forEach","value","is_covered","row_union","row1","row2","map","e","pos","charAt","includes","join","every","check_prime_lines","S","SA","filter","l","add_elt_in_S","new_elt","added_list","push","add_elt_in_E","suffix_list","suffix","E","s","make_member","is_close","find","t","some","same_row","is_consistent","s1_ind","s2_ind","s1","s2","value_s1","value_s2","a","value_s1_p","value_s2_p","i","make_automaton","wordForState","states","Map","acceptingStates","initialStates","name","get","state","isAccepting","isInitial","set","word","symbol","rowNext","name1","transitions","automaton","table_to_update_after_equiv","answer"],"mappings":"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","sourcesContent":["import { Automaton, State } from \"../automaton/Automaton.js\";\r\nimport { Teacher } from \"../teacher/Teacher.js\";\r\nimport { generate_suffix_list } from \"../tools/Utilities.js\";\r\nimport { LernerBase, Map_string_string } from \"./LernerBase.js\";\r\n\r\nexport class NL_star extends LernerBase {\r\n  prime_lines: string[];\r\n\r\n  constructor(teacher: Teacher) {\r\n    super(teacher);\r\n    this.prime_lines = Array.from(this.alphabet).concat(\"\");\r\n  }\r\n\r\n  is_prime(row_key: string): boolean {\r\n    if (this.prime_lines == undefined) this.prime_lines = []\r\n    let row_value = this.observation_table[row_key];\r\n\r\n    if (row_value.length < 2 || parseInt(row_value) == 0) return true;\r\n\r\n    let res = \"0\".repeat(row_value.length)\r\n\r\n    // let res = \"\"\r\n    // for (let i = 0; i < row_value.length; i++) res += \"0\";\r\n\r\n    Object.values(this.observation_table).forEach(value => {\r\n      if (value != row_value && this.is_covered(value, row_value)) {\r\n        res = this.row_union(res, value);\r\n      }\r\n    });\r\n    return res != row_value;\r\n  }\r\n\r\n  /**\r\n   * Given two rows, {@link row1} and {@link row2} \r\n   * it return the union of them, that is the logic \r\n   * or of them, for exemple : row_union(0101, 0110) \r\n   * returns 0111\r\n   */\r\n  row_union(row1: string, row2: string): string {\r\n    return Array.from(row1).map((e, pos) => [e, row2.charAt(pos)].includes(\"1\") ? \"1\" : \"0\").join(\"\");\r\n  }\r\n\r\n  /**\r\n   * returns if {@link row1} is covered by {@link row2}\r\n   * row1 is covered if every bit of is smaller then the \r\n   * corresponding bit of row2. For exemple :\r\n   * 01100 is covered by 01110\r\n   * 01101 is not covered by 01110 (due to last bit of r1)\r\n   */\r\n  is_covered(row1: string, row2: string): boolean {\r\n    return Array.from(row1).every((e, pos) => e <= row2.charAt(pos));\r\n  }\r\n\r\n  check_prime_lines() {\r\n    this.prime_lines = [...this.S, ...this.SA].filter(l => this.is_prime(l));\r\n  }\r\n\r\n  add_elt_in_S(new_elt: string): string[] {\r\n    let added_list = super.add_elt_in_S(new_elt);\r\n    added_list.forEach(e => {\r\n      if (!this.prime_lines?.includes(e) && this.is_prime(e)) {\r\n        this.prime_lines.push(e);\r\n        this.check_prime_lines();\r\n      }\r\n    })\r\n    return added_list;\r\n  }\r\n\r\n  /**\r\n  * For all suffix suff of {@link new_elt} if suff is not in {@link E} :\r\n  * add suff to {@link E} and make queries for every elt in {@link SA} and\r\n  * {@link S} relating to the new column suff\r\n  */\r\n  add_elt_in_E(new_elt: string) {\r\n    let suffix_list = generate_suffix_list(new_elt);\r\n    for (const suffix of suffix_list) {\r\n      if (this.E.includes(suffix)) break;\r\n      this.SA.forEach(s => this.make_member(s, suffix));\r\n      this.S.forEach(s => this.make_member(s, suffix));\r\n      this.E.push(suffix);\r\n    }\r\n    this.check_prime_lines()\r\n  }\r\n\r\n  /**\r\n   * @returns the first `s` in {@link SA} st `s` is a prime line and \r\n   * `s` is not in {@link S}\r\n   */\r\n  is_close(): string | undefined {\r\n    return this.SA.find(t => !this.S.some(s => this.same_row(s, t)) && this.prime_lines.includes(t));\r\n  }\r\n\r\n  /**\r\n   * @returns a list of 3 elements, \r\n   * the first two are s1, s2 in {@link S} st row(s1) is covered by row(s2)\r\n   * and there is an \"a\" in alphabet st row(s1 + a) is not covered row(s2 + a)\r\n   */\r\n  is_consistent(): string[] | undefined {\r\n    for (let s1_ind = 0; s1_ind < this.S.length; s1_ind++) {\r\n      for (let s2_ind = s1_ind + 1; s2_ind < this.S.length; s2_ind++) {\r\n        let s1 = this.S[s1_ind];\r\n        let s2 = this.S[s2_ind];\r\n        let value_s1 = this.observation_table[s1];\r\n        let value_s2 = this.observation_table[s2];\r\n        if (this.is_covered(value_s1, value_s2)) {\r\n          for (const a of this.alphabet) {\r\n            let value_s1_p = this.observation_table[s1 + a]\r\n            let value_s2_p = this.observation_table[s2 + a]\r\n            if (!this.is_covered(value_s1_p, value_s2_p)) {\r\n              for (let i = 0; i < this.E.length; i++) {\r\n                if (this.observation_table[s1 + a][i] <\r\n                  this.observation_table[s2 + a][i] && !this.E.includes(a + this.E[i])) {\r\n                  return [s1, s2, a + this.E[i]]\r\n                }\r\n              }\r\n            }\r\n          }\r\n        } else if (this.is_covered(value_s2, value_s1)) {\r\n          for (const a of this.alphabet) {\r\n            let value_s1_p = this.observation_table[s1 + a]\r\n            let value_s2_p = this.observation_table[s2 + a]\r\n            if (!this.is_covered(value_s2_p, value_s1_p))\r\n              for (let i = 0; i < this.E.length; i++) {\r\n                if (this.observation_table[s1 + a][i] <\r\n                  this.observation_table[s2 + a][i] && !this.E.includes(a + this.E[i])) {\r\n                  return [s2, s1, a + this.E[i]]\r\n                }\r\n              }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  make_automaton() {\r\n    let wordForState: string[] = [], states: Map<string, State> = new Map(),\r\n      acceptingStates: State[] = [], initialStates: State[] = [];\r\n    this.prime_lines.forEach(s => {\r\n      if (this.S.includes(s)) {\r\n        let name = this.observation_table[s];\r\n        if (!states.get(name)) {\r\n          let state = new State(name, name[0] == \"1\", this.is_covered(name, this.observation_table[\"\"]), this.alphabet);\r\n          wordForState.push(s);\r\n          if (state.isAccepting) acceptingStates.push(state)\r\n          if (state.isInitial) initialStates.push(state)\r\n          states.set(name, state);\r\n        }\r\n      }\r\n    })\r\n    for (const word of wordForState) {\r\n      let name = this.observation_table[word]\r\n      for (const symbol of this.alphabet) {\r\n        let rowNext = this.observation_table[word + symbol]\r\n        for (const [name1, state] of states) {\r\n          if (this.is_covered(name1, rowNext))\r\n            states.get(name)!.transitions.get(symbol)!.push(state)\r\n        }\r\n      }\r\n    }\r\n    this.automaton = new Automaton(\r\n      {\r\n        states: states,\r\n        acceptingStates: acceptingStates,\r\n        alphabet: this.alphabet,\r\n        initialStates: initialStates\r\n      }\r\n    )\r\n    return this.automaton;\r\n  }\r\n\r\n  table_to_update_after_equiv(answer: string): void {\r\n    this.add_elt_in_E(answer);\r\n  }\r\n}"],"file":"NL_star.js"}