{"version":3,"sources":["../../src/lerners/NL_star.ts"],"names":["Automaton","generate_suffix_list","LernerBase","NL_star","constructor","teacher","prime_lines","Array","from","alphabet","concat","is_prime","row_key","undefined","row_value","observation_table","length","parseInt","res","i","Object","values","forEach","value","is_covered","row_union","row1","row2","map","e","pos","charAt","includes","join","every","check_prime_lines","S","SA","filter","l","add_elt_in_S","new_elt","added_list","push","add_elt_in_E","suffix_list","suffix","E","s","make_member","is_close","find","t","some","same_row","is_consistent","s1_ind","s2_ind","s1","s2","value_s1","value_s2","a","value_s1_p","value_s2_p","make_automaton","states","first_state","row_e","keys","end_states","k","transitions","state","symbol","fromState","toStates","v","automaton","table_to_update_after_equiv","answer"],"mappings":"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","sourcesContent":["import { Automaton, Transition } from \"../automaton/Automaton.js\";\r\nimport { Teacher } from \"../teacher/Teacher.js\";\r\nimport { generate_suffix_list } from \"../tools/Utilities.js\";\r\nimport { LernerBase, Map_string_string } from \"./LernerBase.js\";\r\n\r\nexport class NL_star extends LernerBase {\r\n  prime_lines: string[];\r\n\r\n  constructor(teacher: Teacher) {\r\n    super(teacher);\r\n    this.prime_lines = Array.from(this.alphabet).concat(\"\");\r\n  }\r\n\r\n  is_prime(row_key: string): boolean {\r\n    if (this.prime_lines == undefined) this.prime_lines = []\r\n    let row_value = this.observation_table[row_key];\r\n\r\n    if (row_value.length < 2 || parseInt(row_value) == 0) return true;\r\n\r\n    let res = \"\"\r\n    for (let i = 0; i < row_value.length; i++) res += \"0\";\r\n\r\n    Object.values(this.observation_table).forEach(value => {\r\n      if (value != row_value && this.is_covered(value, row_value)) {\r\n        res = this.row_union(res, value);\r\n      }\r\n    });\r\n    return res != row_value;\r\n  }\r\n\r\n  /**\r\n   * Given two rows, {@link row1} and {@link row2} \r\n   * it return the union of them, that is the logic \r\n   * or of them, for exemple : row_union(0101, 0110) \r\n   * returns 0111\r\n   */\r\n  row_union(row1: string, row2: string): string {\r\n    return Array.from(row1).map((e, pos) => [e, row2.charAt(pos)].includes(\"1\") ? \"1\" : \"0\").join(\"\");\r\n  }\r\n\r\n  /**\r\n   * returns if {@link row1} is covered by {@link row2}\r\n   * row1 is covered if every bit of is smaller then the \r\n   * corresponding bit of row2. For exemple :\r\n   * 01100 is covered by 01110\r\n   * 01101 is not covered by 01110 (due to last bit of r1)\r\n   */\r\n  is_covered(row1: string, row2: string): boolean {\r\n    return Array.from(row1).every((e, pos) => e <= row2.charAt(pos));\r\n  }\r\n\r\n  check_prime_lines() {\r\n    this.prime_lines = [...this.S, ...this.SA].filter(l => this.is_prime(l));\r\n  }\r\n\r\n  add_elt_in_S(new_elt: string): string[] {\r\n    let added_list = super.add_elt_in_S(new_elt);\r\n    added_list.forEach(e => {\r\n      if (!this.prime_lines?.includes(e) && this.is_prime(e)) {\r\n        this.prime_lines.push(e);\r\n        this.check_prime_lines();\r\n      }\r\n    })\r\n    return added_list;\r\n  }\r\n\r\n  /**\r\n  * For all suffix suff of {@link new_elt} if suff is not in {@link E} :\r\n  * add suff to {@link E} and make queries for every elt in {@link SA} and\r\n  * {@link S} relating to the new column suff\r\n  */\r\n  add_elt_in_E(new_elt: string) {\r\n    let suffix_list = generate_suffix_list(new_elt);\r\n    for (const suffix of suffix_list) {\r\n      if (this.E.includes(suffix)) break;\r\n      this.SA.forEach(s => this.make_member(s, suffix));\r\n      this.S.forEach(s => this.make_member(s, suffix));\r\n      this.E.push(suffix);\r\n    }\r\n    this.check_prime_lines()\r\n  }\r\n\r\n  /**\r\n   * @returns the first `s` in {@link SA} st `s` is a prime line and \r\n   * `s` is not in {@link S}\r\n   */\r\n  is_close(): string | undefined {\r\n    return this.SA.find(t => !this.S.some(s => this.same_row(s, t)) && this.prime_lines.includes(t));\r\n  }\r\n\r\n  /**\r\n   * @returns a list of 3 elements, \r\n   * the first two are s1, s2 in {@link S} st row(s1) is covered by row(s2)\r\n   * and there is an \"a\" in alphabet st row(s1 + a) is not covered row(s2 + a)\r\n   */\r\n  is_consistent(): string[] | undefined {\r\n    for (let s1_ind = 0; s1_ind < this.S.length; s1_ind++) {\r\n      for (let s2_ind = s1_ind + 1; s2_ind < this.S.length; s2_ind++) {\r\n        let s1 = this.S[s1_ind];\r\n        let s2 = this.S[s2_ind];\r\n        let value_s1 = this.observation_table[s1];\r\n        let value_s2 = this.observation_table[s2];\r\n        if (this.is_covered(value_s1, value_s2)) {\r\n          for (const a of this.alphabet) {\r\n            let value_s1_p = this.observation_table[s1 + a]\r\n            let value_s2_p = this.observation_table[s2 + a]\r\n            if (!this.is_covered(value_s1_p, value_s2_p)) {\r\n              for (let i = 0; i < this.E.length; i++) {\r\n                if (this.observation_table[s1 + a][i] <\r\n                  this.observation_table[s2 + a][i] && !this.E.includes(a + this.E[i])) {\r\n                  return [s1, s2, a + this.E[i]]\r\n                }\r\n              }\r\n            }\r\n          }\r\n        } else if (this.is_covered(value_s2, value_s1)) {\r\n          for (const a of this.alphabet) {\r\n            let value_s1_p = this.observation_table[s1 + a]\r\n            let value_s2_p = this.observation_table[s2 + a]\r\n            if (!this.is_covered(value_s2_p, value_s1_p))\r\n              for (let i = 0; i < this.E.length; i++) {\r\n                if (this.observation_table[s1 + a][i] <\r\n                  this.observation_table[s2 + a][i] && !this.E.includes(a + this.E[i])) {\r\n                  return [s2, s1, a + this.E[i]]\r\n                }\r\n              }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  make_automaton() {\r\n    let states: Map_string_string = {}\r\n    this.S.filter(e => this.prime_lines.includes(e)).forEach(e => states[this.observation_table[e]] = e);\r\n\r\n    let first_state = this.S.filter(e => {\r\n      let row_e = this.observation_table[e];\r\n      return this.prime_lines.includes(e) && this.is_covered(row_e, this.observation_table[\"\"])\r\n    })!.map(e => this.observation_table[e]);\r\n    let keys = Object.keys(states);\r\n    let end_states: string[] = keys.filter(k => k[0] == '1');\r\n    // let transitions = keys.map(\r\n    //   (k) => this.alphabet.map(a => {\r\n    //     return keys.filter(v => this.is_covered(v, this.observation_table[states[k] + a]));\r\n    //   }));\r\n    let transitions: Transition[] = [];\r\n    for (const state of this.S) {\r\n      if (!this.prime_lines.includes(state)) continue\r\n      for (const symbol of this.alphabet) {\r\n        transitions.push({\r\n          fromState: this.observation_table[state],\r\n          symbol: symbol,\r\n          toStates: keys.filter(v => this.is_covered(v, this.observation_table[state + symbol]))\r\n        })\r\n      }\r\n    }\r\n    this.automaton = new Automaton({\r\n      \"alphabet\": this.alphabet,\r\n      \"acceptingStates\": end_states,\r\n      \"startState\": first_state,\r\n      \"states\": keys,\r\n      \"transitions\": transitions\r\n    })\r\n    return this.automaton;\r\n  }\r\n\r\n\r\n  table_to_update_after_equiv(answer: string): void {\r\n    this.add_elt_in_E(answer);\r\n  }\r\n}"],"file":"NL_star.js"}