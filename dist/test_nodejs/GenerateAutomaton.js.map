{"version":3,"sources":["../../src/test_nodejs/GenerateAutomaton.ts"],"names":["existsSync","mkdirSync","readdirSync","writeFileSync","Automaton","State","myLog","path","iterationNumber","minStateNumber","maxStateNumber","maxFilePerFolder","maxAutomatonStates","folders","Set","Array","fill","map","_","pos","randInt","max","res","Math","floor","random","reachableFromState","s","l","toExplore","length","shift","pop","neigh","alphabet","e","getSuccessor","flat","state","has","add","push","from","stateNumber","size","counter","states","i","addTransition","newInitial","isInitial","reachable","isAccepting","automaton","minimized","minimize","folderName","state_number","dirElementNb","delete","toString"],"mappings":"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","sourcesContent":["import { minimizeAutomaton } from \"../automaton/automaton_type.js\";\r\nimport { existsSync, mkdirSync, readdirSync, writeFileSync } from \"fs\";\r\nimport { Automaton, State } from \"../automaton/Automaton.js\";\r\nimport { myLog } from \"../tools/Utilities.js\";\r\n\r\n/**\r\n * The goal of this file is to create random \r\n * minimized automaton and store them in \"./statistics/automata/\"\r\n * folder. Every folder will have a {@link maxFilePerFolder} and\r\n * the max number of state of a minimized automaton will be:\r\n * {@link maxAutomatonStates}\r\n */\r\n\r\nlet path = \"./statistics/automata/\",\r\n  iterationNumber = 5000,\r\n  minStateNumber = 10,\r\n  maxStateNumber = 350,\r\n  maxFilePerFolder = 40,\r\n  maxAutomatonStates = 200,\r\n  folders = new Set(new Array(maxAutomatonStates).fill(1).map((_, pos) => pos + 1));\r\n\r\nconst randInt = (max: number) => {\r\n  let res = Math.floor(Math.random() * max)\r\n  return res;\r\n}\r\n\r\nconst reachableFromState = (s: State) => {\r\n  let l: Set<State> = new Set();\r\n  let toExplore: State[] = [s];\r\n  while (toExplore.length > 0) {\r\n    let shift = toExplore.pop()!;\r\n    let neigh = new Set(s.alphabet.map(e => shift.getSuccessor(e)).flat());\r\n    for (const state of neigh) {\r\n      if (!l.has(state)) {\r\n        l.add(state);\r\n        toExplore.push(state);\r\n      }\r\n    }\r\n  }\r\n  return Array.from(l);\r\n}\r\n\r\nfor (let stateNumber = minStateNumber; stateNumber < maxStateNumber; stateNumber += 10) {\r\n  if (folders.size == 0) break;\r\n  myLog(\"Iteration =\", stateNumber, \"Folder to fill :\", folders.size);\r\n\r\n  for (let counter = 0; counter < iterationNumber; counter++) {\r\n    if (folders.size == 0) break;\r\n    const states: State[] = [];\r\n    for (let i = 0; i < stateNumber; i++) {\r\n      states.push(new State(i + '', false, false, 'ab'));\r\n    }\r\n\r\n    for (const state of states) {\r\n      state.addTransition('a', states[randInt(stateNumber)])\r\n      state.addTransition('b', states[randInt(stateNumber)])\r\n    }\r\n\r\n\r\n    let newInitial = states[randInt(stateNumber)];\r\n    newInitial.isInitial = true\r\n    let reachable = reachableFromState(newInitial)\r\n\r\n    for (let i = 0; i < randInt(reachable.length); i++) {\r\n      reachable[randInt(reachable.length)].isAccepting = true\r\n    }\r\n\r\n    let automaton = new Automaton(states),\r\n      minimized = automaton.minimize(),\r\n      folderName = minimized.state_number();\r\n\r\n    if (folderName > maxAutomatonStates) continue;\r\n\r\n    if (!existsSync(path + folderName)) mkdirSync(path + folderName);\r\n\r\n    let dirElementNb = readdirSync(path + folderName).length;\r\n\r\n    if (dirElementNb > maxFilePerFolder) {\r\n      folders.delete(folderName);\r\n      continue;\r\n    }\r\n\r\n    writeFileSync(path + folderName + \"/\" + dirElementNb + \".ba\", minimized.toString());\r\n    myLog(\"State Number =\", stateNumber, \"Counter =\", counter, \"StateNb =\", folderName);\r\n  }\r\n}"],"file":"GenerateAutomaton.js"}