{"version":3,"sources":["../../src/test_nodejs/GenerateAutomaton.ts"],"names":["existsSync","mkdirSync","readdirSync","writeFileSync","Automaton","State","path","iterationNumber","minStateNumber","maxStateNumber","maxFilePerFolder","maxAutomatonStates","folders","Set","Array","fill","map","_","pos","randInt","max","res","Math","floor","random","reachableFromState","s","l","toExplore","length","shift","pop","neigh","alphabet","e","getSuccessor","flat","state","has","add","push","from","stateNumber","size","console","log","counter","states","i","addTransition","newInitial","isInitial","reachable","isAccepting","automaton","minimized","minimize","folderName","state_number","dirElementNb","delete","toString"],"mappings":"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","sourcesContent":["import { minimizeAutomaton } from \"../automaton/automaton_type.js\";\r\nimport { existsSync, mkdirSync, readdirSync, writeFileSync } from \"fs\";\r\nimport { Automaton, State } from \"../automaton/Automaton.js\";\r\n\r\n/**\r\n * The goal of this file is to create random \r\n * minimized automaton and store them in \"./statistics/automata/\"\r\n * folder. Every folder will have a {@link maxFilePerFolder} and\r\n * the max number of state of a minimized automaton will be:\r\n * {@link maxAutomatonStates}\r\n */\r\n\r\nlet path = \"./statistics/automata/\",\r\n  iterationNumber = 5000,\r\n  minStateNumber = 10,\r\n  maxStateNumber = 350,\r\n  maxFilePerFolder = 40,\r\n  maxAutomatonStates = 200,\r\n  folders = new Set(new Array(maxAutomatonStates).fill(1).map((_, pos) => pos + 1));\r\n\r\nconst randInt = (max: number) => {\r\n  let res = Math.floor(Math.random() * max)\r\n  return res;\r\n}\r\n\r\nconst reachableFromState = (s: State) => {\r\n  let l: Set<State> = new Set();\r\n  let toExplore: State[] = [s];\r\n  while (toExplore.length > 0) {\r\n    let shift = toExplore.pop()!;\r\n    let neigh = new Set(s.alphabet.map(e => shift.getSuccessor(e)).flat());\r\n    for (const state of neigh) {\r\n      if (!l.has(state)) {\r\n        l.add(state);\r\n        toExplore.push(state);\r\n      }\r\n    }\r\n  }\r\n  return Array.from(l);\r\n}\r\n\r\nfor (let stateNumber = minStateNumber; stateNumber < maxStateNumber; stateNumber += 10) {\r\n  if (folders.size == 0) break;\r\n  console.log(\"Iteration =\", stateNumber, \"Folder to fill :\", folders.size);\r\n\r\n  for (let counter = 0; counter < iterationNumber; counter++) {\r\n    if (folders.size == 0) break;\r\n    const states: State[] = [];\r\n    for (let i = 0; i < stateNumber; i++) {\r\n      states.push(new State(i + '', false, false, 'ab'));\r\n    }\r\n\r\n    for (const state of states) {\r\n      state.addTransition('a', states[randInt(stateNumber)])\r\n      state.addTransition('b', states[randInt(stateNumber)])\r\n    }\r\n\r\n\r\n    let newInitial = states[randInt(stateNumber)];\r\n    newInitial.isInitial = true\r\n    let reachable = reachableFromState(newInitial)\r\n\r\n    for (let i = 0; i < randInt(reachable.length); i++) {\r\n      reachable[randInt(reachable.length)].isAccepting = true\r\n    }\r\n\r\n    let automaton = new Automaton(states),\r\n      minimized = automaton.minimize(),\r\n      folderName = minimized.state_number();\r\n\r\n    if (folderName > maxAutomatonStates) continue;\r\n\r\n    if (!existsSync(path + folderName)) mkdirSync(path + folderName);\r\n\r\n    let dirElementNb = readdirSync(path + folderName).length;\r\n\r\n    if (dirElementNb > maxFilePerFolder) {\r\n      folders.delete(folderName);\r\n      continue;\r\n    }\r\n\r\n    writeFileSync(path + folderName + \"/\" + dirElementNb + \".ba\", minimized.toString());\r\n    console.log(\"State Number =\", stateNumber, \"Counter =\", counter, \"StateNb =\", folderName);\r\n  }\r\n}"],"file":"GenerateAutomaton.js"}