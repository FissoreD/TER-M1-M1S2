\section{Introduction}

\subsection{Lerning from Teacher}

As human we can face new situations, new problems that we want to solve in order to accomplish a particular task.
Imagine you are in a foreign country and you want to take a beverage from a vending machine using an alphabet you don't know. The first thing you do is trying to make some attemps to find the right procedure to select the product you want. At the end thanks to the answers given by the vending machine you will be able to understand the right path of actions to follow in order to get your beverage.

Similarly, in computer science, it is interesting to create a system able to understand an unknown language performing actions, registering their consequence until it has enough information to say that the language is now learnt. This process can be represented by a \lerner{}, the system willing to learn the new language, and a \teacher{}, the oracle containing the unknwon language which will answer about the validity or not of the received question.

The interactions between \lerner{} and \teacher{} are various, for instance, \teacher{} may give informations to the \lerner{} without being solliceted, it can provide not relible or useless informations and so on and mutually the \lerner{} may not make well-formed questions or may not keep attention to the answers it will get.
In this project, we are going to reduce our world and allow only two main kinds of communication, such as
\textit{query(q)} where the \lerner{} asks if a sentence \textit{q} belongs to the unknown language and the \teacher{} can answer \textit{yes} or \textit{no} and
\textit{member(M)} where the \lerner{} send a prediction \textit{M} (in the form of an automaton) and the \teacher{} answers either \textit{yes} if \textit{M} defines the good language, otherwise provides a counter-exmple invalidating \textit{M}.
\subsection{Structure of this report}
In this report we are going to illustrate briefly the concept of \textit{Finate State Automata} defining "regular languages".

Then we are going to introduce the L* \cite{angluinL} and the NL* \cite{angluinNL} algorithms and finally we compare them in term of performances and quality of results.