\section{Finate State Automaton}

\subsection{Description}
An automaton \automaton{} is a computing device used in abstract computer science to understand a regular language \lang{} which can be seen as a set of words formed with the concatenation of zero or more letters \letter{} belonging to an alphabet, and a finite set of symbols, noted \alphabet{}.

\begin{theorem}[Kleene's theorem]
    A language is called regular if it can be represented by a regular expression, a finite state automaton or a context free grammar.
\end{theorem}

Here are some examples of regular langauges and their corresponting automata are shown in \cref{simple_automata}.
\begin{example}{Epsilon language}
    \label{example:lang_eps}
    $L = \{\varepsilon\}$ is the language with only a word of length zero.
\end{example}

\begin{example}
    \label{example:lang_ab_len2}
    $L = \{aa, ab, ba, bb\}$ is the language formed by all strings with all combinations of two characters on the alphabet $\Sigma = \{a, b\}$ with corresponding regular expression $(a+b)(a+b)$
\end{example}

\begin{example}
    \label{example:a_plus}
    $L = \{a, aa, ...\}$ is the language of words represented by the regular expression $a^+$.
\end{example}

\begin{figure}[h]
    \centering
    \begin{subfigure}{0.45\textwidth}
        \centering
        \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
            \node[state,initial, accepting, initial text=] (q_I) {$q_I$};
        \end{tikzpicture}
        \caption{Automaton of \cref{example:lang_eps}}
    \end{subfigure}
    \begin{subfigure}{0.45\textwidth}
        \centering
        \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
            \node[state,initial text=, initial] (q_I) {$q_I$};
            \node[state] (q_1) [right=of q_I] {$q_1$};
            \node[state, accepting] (q_2) [right=of q_1] {$q_2$};
            \path[->]
            (q_I) edge  node {a,b} (q_1)
            (q_1) edge  node {a,b} (q_2);
        \end{tikzpicture}
        \caption{Automaton of \cref{example:lang_ab_len2}}
    \end{subfigure}
    \begin{subfigure}{0.45\textwidth}
        \centering
        \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
            \node[state,initial text=, initial] (q_I) {$q_I$};
            \node[state, accepting] (q_1) [right=of q_I] {$q_1$};
            \path[->]
            (q_I) edge  node {a} (q_1)
            (q_1) edge [loop above] node {a} ();
        \end{tikzpicture}
        \caption{Automaton of \cref{example:a_plus}}
    \end{subfigure}
    \caption{Some simple automata}
    \label{simple_automata}
\end{figure}

In \cref{simple_automata} we see that a \textit{finite} automaton is composed by a finite set of states linked by labelled arrows called \textit{transitions}.

The set of states that are directly linked with a state \qi{} are called successor of \qi{} and noted $Succ(q_i)$, and the predecessors of \qi{}, noted $Pred(q_i)$, are those states having \qi{} has a successor. Moreover, if a state is pointed by an arrow with no predecessor, then it is an initial state and if a state is marked with a double cdotle then it is called an accepting state.

We say that a word \word{} is accepted by \automaton{} or belongs to \langA{}, the language recognized by \automaton{}, if, from an initial state we can join an accepting state by reading each letter of \word{}.

\begin{notation}
    An automaton \automaton{} is usually represented by a 5-tuple $\langle$ \alphabet{}, \states{}, \transition{}, \qzero{}, \qend{} $\rangle$ where \alphabet{} is the alphabet, \states{} is the set of states composing the automaton, \transition{} is the set of transition of \automaton{} \qzero{} $\in \statesN{}$ is the starting state and \qend{} is the set of accepting states in \states{}. A transition \transition{} is a triple $(q_i, \alpha, q_j)$ saying that it is possible to go to the state $q_j$ from the state $q_i$ when the symbol $\alpha$ is read.
\end{notation}

\begin{definition}[DFA and NFA]
    If $\forall (q_i, \alpha, q_j) \in \transitionN{}, \nexists (q_i, \alpha, q_j') \in \transitionN{} \mid q_j \neq q_j'$ that is, if for every state $q_i \in \statesN{}$, there does not exist two different transitions from \qi{} with the same label, then the automaton is said to be \textit{deterministic} and noted \textit{DFA}, otherwise the automaton is called \textit{non deterministic} and noted \textit{NFA}.
\end{definition}

DFAs have important properties since it is computationally "easy" to test if a word is accepted by \automaton{}. On the other hand a NFA can be exponentially more succint in term of number of states than a DFA, but checking the acceptance of a word in an NFA is in general more difficult task.

\begin{definition}[Minimal automaton]
    An automaton \automaton{} is minimal if it is not possible to construct a smaller automaton $\automatonN{}'$ for the same language having less states than \automaton{}.
\end{definition}

\begin{example}[DFA vs NFA]
    Here an exemple of two minimal automata defining the language over the alphabet $\alphabetN{} = \{a, b\}$ for strings with an $a$ in the second letter from last position (same as $L = regex((a+b)^*a(a+b))$).
    \begin{figure}[h]
        \centering
        \begin{subfigure}{0.45\textwidth}
            \centering
            \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
                \node[state,initial, initial text=] (q_I) {$q_I$};
                \node[state] (q_1) [right=of q_I] {$q_1$};
                \node[state, accepting] (q_2) [right=of q_1] {$q_2$};
                \path[->]
                (q_I) edge [loop above] node {a,b} ()
                (q_I) edge  node {a} (q_1)
                (q_1) edge  node {a,b} (q_2);
            \end{tikzpicture}
            \caption{NFA}
            \label{subfig:nfa_x_star_ax}
        \end{subfigure}
        \begin{subfigure}{0.45\textwidth}
            \centering
            \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
                \node[state,initial, initial text=] (q_I) {$q_I$};
                \node[state] (q_1) [right=of q_I] {$q_1$};
                \node[state, accepting] (q_2) [above right=of q_1] {$q_2$};
                \node[state, accepting] (q_3) [below right=of q_1] {$q_3$};
                \path[->]
                (q_I) edge [loop above] node {b} ()
                (q_2) edge [loop above] node {a} ()
                (q_I) edge  node {a} (q_1)
                (q_1) edge  node {a} (q_2)
                (q_1) edge  node {a} (q_2)
                (q_2) edge  node {b} (q_3)
                (q_3) edge[bend left, below]  node {b} (q_I)
                (q_3) edge[bend left, below]  node {a} (q_1)
                (q_1) edge[bend left, above]  node {b} (q_3);
            \end{tikzpicture}
            \caption{DFA}
            \label{subfig:dfa_x_star_ax}
        \end{subfigure}
        \caption{NFA vs DFA}
        \label{fig:nfa_vs_dfa}
    \end{figure}
    In \cref{fig:nfa_vs_dfa} you see that the NFA needs less states then the corresponding mimimum DFA, but if we are in state $q_I$ and we read an $a$ we can go either in state $q_I$ or in state $q_1$. It's this ambiguity that makes the NFA difficult to treat.
\end{example}

% \begin{theorem}
%   Every DFA has an unique minimal DFA representing the same langauge with the minimal number of states and to know if two DFAs are equivalent, we can minimize and compare them.
% \end{theorem}

% \begin{theorem}
%   An NFA has not a unique minimal representation and to compare two NFAs, in general, we must transform them in DFA and then test the equality.
% \end{theorem}

% Since the goal of this paper is not to minimize automata, we are going to consider DFA and NFA as if they are always in the minimized form.